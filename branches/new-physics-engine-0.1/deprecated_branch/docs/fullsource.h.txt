
//----------------------------
// window.h
//----------------------------

// represents a window
#ifndef WINDOW_H
#define WINDOW_H

#include <allegro.h>
#include <stdio.h>

// class Window;

#include "globals.h"
#include "gameState.h"
#include "gameBase.h"

// Modes for creating the display
// Listed in order from fastest, but nastier, to slowest, but nicest

// NO buffering (fastest, looks bad) NOT RECOMMENDED
#define MODE_NOBUFFERING			0

// Double buffering (reduces tearing) recommended default
#define MODE_DOUBLEBUFFERING	1

// Page flipping, (really reduces tearing)
#define MODE_PAGEFLIPPING			2

// Tripe buffering, (slowest, looks nicest) 
// ONLY use this on really fast machines where you can still
// see flickering or tearing.
#define MODE_TRIPLEBUFFERING	3

class Window : public GameBase {
	protected:
		bool initialized;
		uint width, height;
		int mode;

		//! Points to a surface we can draw to.
		BITMAP* drawing_surface;
		
		// For page flipping
		BITMAP* page[2];
		uint active_page;			// index of the page NOT being
													// displayed (ok to draw on)
		
		// For double buffering
		BITMAP* backbuf;
		
	public:
		int Init(	GameState* _game_state, 
							uint _width, uint _height, bool _fullscreen = 0,
							int _mode = MODE_DOUBLEBUFFERING);

		void Shutdown();

		inline BITMAP* GetDrawingSurface() {return drawing_surface;};
		void Clear();
		void Flip();

		inline uint Width() {return width;};
		inline uint Height() {return height;};

		Window();
		~Window();
};

#endif // WINDOW_H

//----------------------------
// window.cpp
//----------------------------

#include "window.h"

int Window::Init(	GameState* _game_state, 
									uint _width, uint _height, 
									bool _fullscreen, int _mode) {
	
	int gfx_mode;
	int vheight;
	
	SetGameState(_game_state);

	width = _width;
	height = _height;
	mode = _mode;
	
	if (_fullscreen)
			gfx_mode = GFX_AUTODETECT_FULLSCREEN;
	else
			gfx_mode = GFX_AUTODETECT;

	if (mode == MODE_PAGEFLIPPING || mode == MODE_TRIPLEBUFFERING)
		vheight = height * 2;
	else 
		vheight = 0;

	if (set_gfx_mode(gfx_mode, width, height, 0, vheight) != 0) {
		fprintf(stderr, 
						"window: Can't set graphics mode! (%i, %i, fullscreen = %i) \n"
						"Try setting a different graphics mode or try non-fullscreen\n",
						width, height, _fullscreen);
		return -1;
	}	

	set_window_title(VERSION_STRING);
	
	if (mode == MODE_DOUBLEBUFFERING) {
		clear_bitmap(screen);
		
		// initialize back buffering
		backbuf = create_bitmap(width, height);
		if (!backbuf) {
			fprintf(stderr, "window: can't create back buffer!\n");
			return -2;
		}
		
		clear_bitmap(backbuf);
		drawing_surface = backbuf;
		
	} else if (mode == MODE_PAGEFLIPPING) {
	
		// set up page flipping
		page[0] = create_video_bitmap(width, height);
		page[1] = create_video_bitmap(width, height);

		if ((!page[0]) || (!page[1])) {
			fprintf(stderr, "window: can't setup page flipping!\n");
			return -2;
		}

		active_page = 0;
		drawing_surface = page[active_page];
		
	} else if (mode == MODE_NOBUFFERING) {

		clear_bitmap(screen);
		drawing_surface = screen;
		
	} else {
		
		fprintf(stderr, "window: specified mode not supported!\n");
		return -2;
		
	}

	initialized = true;

	return 0;
}

void Window::Clear() {
	switch (mode) {
		case MODE_PAGEFLIPPING:
			clear_bitmap(page[active_page]);
			break;
		case MODE_DOUBLEBUFFERING:
			clear_bitmap(backbuf);
			break;
		case MODE_NOBUFFERING:
			clear_bitmap(screen);
			break;
		default:
			fprintf(stderr, "ERROR: Unkown buffering mode %u\n", mode);
	}
}

// draws the backbuffer to the screen and erases the backbuffer
void Window::Flip() {
	vsync();
	if (mode == MODE_PAGEFLIPPING) {
		show_video_bitmap(page[active_page]);
	
		if (active_page == 1)
			active_page = 0;
		else 
			active_page = 1;
	
		drawing_surface = page[active_page];
	} else if (mode == MODE_DOUBLEBUFFERING) {
		blit(backbuf, screen, 0, 0, 0, 0, width, height);
	} else if (mode == MODE_NOBUFFERING) {
		// do nothing	
	}
}

void Window::Shutdown() {
	if (!initialized)
			return;

	if (mode == MODE_PAGEFLIPPING) {
		destroy_bitmap(page[0]);
		destroy_bitmap(page[1]);
	} else if (mode == MODE_DOUBLEBUFFERING) {
		destroy_bitmap(backbuf);
	}
	
	drawing_surface = NULL;
	release_screen();
	initialized = false;
}

Window::Window() : initialized(false), drawing_surface(NULL) {
	page[0] = NULL;
	page[1] = NULL;
}
Window::~Window() {}

//----------------------------
// vector2D.h
//----------------------------

#ifndef VECTOR2D_H
#define VECTOR2D_H

#include <stdio.h>
#include <math.h>
#include <vector>

using namespace std;

class Vector2D;

//! A fudge value.  You can't compare two floats
//! directly, we just want to know if they are close.
//! This defines how close they must be to be considered
//! 'equal'
#define TOLERANCE 0.00001

// #include "globals.h"
// #include "force.h"

class Vector2D {
	protected:
		float x, y;
		
	public:
		void Clear();

		inline float GetX() const {return x;}
	 	inline float GetY() const {return y;}
		inline void SetX(float _x) {x=_x;}
	 	inline void SetY(float _y) {y=_y;}
		
		//! Assign a vector's values to this vector
		/*inline Vector2D Vector2D::operator=(const Vector2D &v) {
			x = v.GetX();
			y = v.GetY();
			return ;
		}*/
	
		//! Add two vectors
		inline Vector2D Vector2D::operator+(const Vector2D &v) const {
			return Vector2D(x + v.GetX(), y + v.GetY());
		}

		//! Add another vector to this one
		inline void Vector2D::operator+=(const Vector2D &v) {
			x += v.GetX();
			y += v.GetY();
		}

		//! Subtract another vector from this one
		inline void Vector2D::operator-=(const Vector2D &v) {
			x -= v.GetX();
			y -= v.GetY();
		}

		//! Subtract two vectors
		inline Vector2D Vector2D::operator-(const Vector2D &v) const {
			return Vector2D(x - v.GetX(), y - v.GetY());
		}
		
		//! Compare two vectors
		inline bool Vector2D::operator==(const Vector2D &v) const {
			return (x - v.GetX() < TOLERANCE && x - v.GetX() > -TOLERANCE &&
							y - v.GetY() < TOLERANCE && y - v.GetY() > -TOLERANCE);
		}
		
		//! Compare two vectors
		inline bool Vector2D::operator!=(const Vector2D &v) const {
				return (x - v.GetX() > TOLERANCE || x - v.GetX() < -TOLERANCE ||
								y - v.GetY() > TOLERANCE || y - v.GetY() < -TOLERANCE);
		}

		//! Scalar product (vector * number)
		inline Vector2D Vector2D::operator*(float n) const {
			return Vector2D(x*n, y*n);
		}
		
		//! Subtract another vector from this one
		inline void Vector2D::operator*=(float n) {
			x *= n;
			y *= n;
		}


		//! Scalar product (vector * number)
		//XXX need to add exception handling for DIVIDE by ZERO
		inline Vector2D Vector2D::operator/(float n) const {
			return Vector2D(x/n, y/n);
		}

		//! Compute the dot product
		inline float Dot(const Vector2D &v) const {
			return (x * v.GetX()) + (y * v.GetY());
		}
		
		//! Compute the cross product
		/*inline Vector2D cross(Vector2D v) const {

		}*/
		
		Vector2D();
		Vector2D(float _x, float _y);
		virtual ~Vector2D();
};

#endif // VECTOR2D_H

//----------------------------
// vector2D.cpp
//----------------------------

#include "vector2D.h"

void Vector2D::Clear() {
	x = y = 0.0f;
}

Vector2D::Vector2D(float _x, float _y) {
	x = _x; y = _y;
}

Vector2D::~Vector2D() {}
Vector2D::Vector2D() : x(0.0f), y(0.0f) {}

// calculate the sum of the forces
// acting on this vector at 1/60th 
// of a second later.  we store things
// internally as float, but return ints
/*int vec::CalcNextStep() {

	int i, max = forces.size();
	
	// 1) calc sum of forces to get new acceleration
	acceleration = 0;
	for (i = 0; i < max; i++)
		acceleration += forces[i]->GetAcceleration();		

	// 2) add acceleration to velocity to get new velocity
	velocity = (velocity + acceleration) * v_decay;
	if (v_decay != 1.0f && velocity < 0.25 && velocity > -0.25)
			velocity = 0;
	
	// 3) add velocity to position to get new position
	position += velocity;
	
	// 4) return the new position
	return GetPosition();
}*/



//----------------------------
// timer.h
//----------------------------

#ifndef TIMER_H
#define TIMER_H

#include <allegro.h>

#include "globals.h"

extern volatile int outstanding_updates;
void Timer();

#endif // TIMER_H

//----------------------------
// timer.cpp
//----------------------------

#include "timer.h"

// For timing stuff
volatile int outstanding_updates = 0;

void Timer(void) {
	outstanding_updates++;
} END_OF_FUNCTION(Timer);

//----------------------------
// resourceLoader.h
//----------------------------

#ifndef RESOURCE_LOADER_H
#define RESOURCE_LOADER_H

#include <stdio.h>
#include <stdarg.h>
#include <vector>
using namespace std;

#include "gameBase.h"
#include "StdString.h"

//! Resource loader class
//! Resolves resource filenames to absolute paths

class ResourceLoader : public GameBase {
	protected:
		vector<CString> paths;
		
	public:
		int Init(GameState*);
		void Shutdown();
		
		//! Set the search path
		//! Takes at least one path
		void SetSearchPath(char* _path, ...);

		//! Append a new path to the search path
		void AppendToSearchPath(char* _path);

		//! Get the absolute path of this resource in the
		//! search path
		CString GetPathOf(char* filename);

		ResourceLoader();
		~ResourceLoader();
};

#endif // RESOURCE_LOADER_H

//----------------------------
// resourceLoader.cpp
//----------------------------

#include "resourceLoader.h"

void ResourceLoader::AppendToSearchPath(char* path) {
	paths.push_back(path);
}

void ResourceLoader::SetSearchPath(char* path, ...) {
	
}

CString ResourceLoader::GetPathOf(char* filename) {
	
}

ResourceLoader::ResourceLoader() {
}

ResourceLoader::~ResourceLoader() {
}

//----------------------------
// platform.h
//----------------------------

// Deals with nasty platform specific stuff.  
// Tons of #ifdef fun

#ifndef PLATFORM_H
#define PLATFORM_H

#include <string.h>
#include <stdio.h>

#include "globals.h"

//! XXX STUPID HACKS FOR NOW
char* get_correct_path(const char* filename);
const char* get_current_working_dir();

#endif

//----------------------------
// platform.cpp
//----------------------------

// Deals with nasty platform specific stuff.  
// Tons of #ifdef fun

#include "platform.h"

#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>

//! XXX STUPID HACK FOR NOW

//! Load a bitmap with the correct 'path'
//! Automagic function to wrap some platform crud
//! before it gets fixed in the real spriteLoader class
//! XXX MEMORY LEAK.  Yes I know.  It is stupid and temporary.
char* get_correct_path(const char* filename) {
	
	const int size=512;
	char *s = (char*)malloc(size);
	
	const char* path = get_current_working_dir();
	// const char* path = "/path/to/whatever.app/Resources/"	

	strncpy(s, path, size-1);
	strncat(s, "Resources/", size-1);
	strncat(s, filename, size-1);

	// couldn't find it.. try..
	struct stat sb;
	if (stat(s, &sb) == -1) {
		strncpy(s, filename, size-1);
	}

	return s;
}

// ONLY needed for MacOSX bundles
#ifdef PLATFORM_DARWIN 

#include <CoreServices/CoreServices.h>
	//! Returns something like '/Applications/Ninjas.app/'
	const char* get_current_working_dir() {
		CFBundleRef mainBundle = CFBundleGetMainBundle();
		CFURLRef url = CFBundleCopyBundleURL(mainBundle);
		CFStringRef cfStr = CFURLCopyPath(url);
		return CFStringGetCStringPtr(cfStr, CFStringGetSystemEncoding());
	}
#else
	const char* get_current_working_dir() {
		return "";
	}
#endif

//----------------------------
// physSimulation.h
//----------------------------

#ifndef PHYS_SYSTEM_H
#define PHYS_SYSTEM_H

#include <vector>

using namespace std;

class PhysSimulation;

#include "globals.h"
#include "gameBase.h"
#include "objectFactory.h"
#include "object.h"
#include "forceFactory.h"
#include "force.h"
#include "forceInput.h"
#include "forceGravity.h"

//! Represents a physical simulation
class PhysSimulation : GameBase {
		protected:		
			//! Collection of all drawable objects
			ObjectList objects;

			//! Collection of forces
			ForceList forces;
		
			//! Creates new objects
			ObjectFactory *objectFactory;

			//! Creates new forces
			ForceFactory *forceFactory;
		
			//! Loads a simulation (eventually from a file)
			int Load();

			void ResetForNextFrame();
			void Solve();
			void UpdateObjects();
		public:

			int Init(GameState* gs);
			void Shutdown();

			void Draw();
			void Update();

			PhysSimulation();
			~PhysSimulation();
};

#endif

//----------------------------
// physSimulation.cpp
//----------------------------

#include "physSimulation.h"

int PhysSimulation::Init(GameState* gs) {
	SetGameState(gs);

	objectFactory = new ObjectFactory();
	if ( !objectFactory || objectFactory->Init(GetGameState()) < 0 ) {
		fprintf(stderr, "ERROR: InitSystem: failed to init objectFactory!\n");
		return -1;
	}

	forceFactory = new ForceFactory();
	if ( !forceFactory || forceFactory->Init(GetGameState()) < 0 ) {
		fprintf(stderr, "ERROR: InitSystem: failed to init forceFactory!\n");
		return -1;
	}

	objects.clear();
	forces.clear();
	
	return Load();
}

void PhysSimulation::Shutdown() {
	int i, max;

	// delete all the objects
	max = objects.size();
	for (i = 0; i < max; i++) {
		objects[i]->Shutdown();
		delete objects[i];
		objects[i] = NULL;
	}
	objects.clear();

	// delete all the forces
	max = forces.size();
	for (i = 0; i < max; i++) {
		forces[i]->Shutdown();
		delete forces[i];
		forces[i] = NULL;
	}
	forces.clear();
			
	// delete the object factory
	if (objectFactory) {
		objectFactory->Shutdown();
		delete objectFactory;
		objectFactory = NULL;
	}

	// delete the force factory
	if (forceFactory) {
		forceFactory->Shutdown();
		delete forceFactory;
		forceFactory = NULL;
	}

	game_state = NULL;
}

//! Draw all objects in this physics simulation
void PhysSimulation::Draw() {
	int i, max = objects.size();

	for (i = 0; i < max; i++) {
		objects[i]->Draw();
	}
}

//! Reset all objects for the next frame
void PhysSimulation::ResetForNextFrame() {
	int i, max = objects.size();

	for (i = 0; i < max; i++) {
		objects[i]->ResetForNextFrame();
	}
}

//! Solve for next frame
void PhysSimulation::Solve() {
	int i, j, max_o, max_f;
	
	max_o = objects.size();
	max_f = forces.size();

	// apply each force to the object
	for (i = 0; i < max_o; i++) {
		for (j = 0; j < max_f; j++) {
			objects[i]->ApplyForce(forces[j]);
		}
	}
}

//! Update all objects
void PhysSimulation::UpdateObjects() {
	int i, max = objects.size();

	for (i = 0; i < max; i++) {
		objects[i]->Update();
	}
}

//! Master update for the Physics simulation
void PhysSimulation::Update() {
	ResetForNextFrame();
	Solve();
	UpdateObjects();
}

//! Eventually, load the initial state from a map file
//! For now, we just create some random objects + forces for a demo
int PhysSimulation::Load() {
				
	Object* new_obj;
	
	int i, max = 5;

	// -- Create some random objects --
	objects.clear();
	
	new_obj = objectFactory->CreateObject(OBJECT_ID_BACKGROUND);
	if (!new_obj)
		return -1;
	
	objects.push_back(new_obj);
	
	for (i = 0; i < max; i++) {
		new_obj = objectFactory->CreateObject(OBJECT_ID_RADIUS_BLOCK);
		if (!new_obj)
			return -1;

		objects.push_back(new_obj);
	}
	
	new_obj = objectFactory->CreateObject(OBJECT_ID_PLAYER);
	if (!new_obj)
		return -1;

	objects.push_back(new_obj);

	// -- Create some forces --
	
	Force* new_force = NULL;
	forces.clear();

	if ( (new_force = forceFactory->CreateForce(FORCE_GRAVITY)) )
		forces.push_back(new_force);
	else
		return -1;
	
	if ( (new_force = forceFactory->CreateForce(FORCE_INPUT)) )
		forces.push_back(new_force);
	else
		return -1;

	return 0;	
}

PhysSimulation::PhysSimulation() : objects(0), forces(0) {}
PhysSimulation::~PhysSimulation() {}

//----------------------------
// objectRadiusBlock.h
//----------------------------

// this file is a TEST ONLY

#ifndef RADIUSBLOCKOBJECT_H
#define RADIUSBLOCKOBJECT_H

#define RADIUS_BLOCK_SPEED 0.01f

#include <math.h>
#include <stdio.h>

class RadiusBlockObject;

#include "globals.h"
#include "object.h"

class RadiusBlockObject : public Object {
	protected:
		float theta;
		int radius;
				
	public:
		bool Init(GameState* _game_state);

		void Update();
		void Draw();

		inline void SetTheta(float angle) { theta = angle; }
		inline float GetTheta() { return theta; }
		inline void SetRadius(int r) { radius = r; }
		inline float GetRadius() { return radius; }

		RadiusBlockObject();
		~RadiusBlockObject();
};

#endif // RadiusBlockObject_H   

//----------------------------
// objectRadiusBlock.cpp
//----------------------------

#include "objectRadiusBlock.h"

void RadiusBlockObject::Update() {
	theta += RADIUS_BLOCK_SPEED;
}

bool RadiusBlockObject::Init(GameState *_game_state) {
		SetGameState(_game_state);
		return true;
}

void RadiusBlockObject::Draw() {
	DrawAtOffset(	int(sinf(theta) * radius) , 
								int(cosf(theta) * radius) );
}

RadiusBlockObject::RadiusBlockObject() : theta(0.0f) {}
RadiusBlockObject::~RadiusBlockObject() {}

//----------------------------
// objectPlayer.h
//----------------------------

// this file is a TEST ONLY

#ifndef PLAYEROBJECT_H
#define PLAYEROBJECT_H

#include <allegro.h>
#include <math.h>
#include <stdio.h>
#include <vector>

using namespace std;

class ObjectPlayer;

#include "globals.h"
#include "object.h"
#include "input.h"
#include "inputLiveHandler.h"
#include "force.h"
#include "forceGravity.h"
#include "forceInput.h"
#include "vector2D.h"

// directions

class PlayerObject : public Object {
	protected:
		BaseInput* input;
				
	public:
		void Update();

		bool Init(GameState* _game_state);
		
		PlayerObject();
		~PlayerObject();
};

#endif // PLAYER_OBJECT_H

//----------------------------
// objectPlayer.cpp
//----------------------------

#include "objectPlayer.h"

#define JUMP_VELOCITY 5.0f
#define DRAG 0.9f

void PlayerObject::Update() {

	int w = game_state->Width();

	// Compute the new position
	pos = Solve();

	// See if we're out of bounds
	if (pos.GetX() < 0) {
		vel.SetX(-vel.GetX());
		pos.SetX(0);
	} else if (pos.GetX() > w - bitmap->w) {
		vel.SetX(-vel.GetX());
		pos.SetX(w - bitmap->w);
	}

	// See if we hit the floor
	if (pos.GetY() < bitmap->h) {
			pos.SetY(bitmap->h);
	}

	// If we're on the floor.. 
	if (pos.GetY() == bitmap->h) {
	
		// Then we can jump.
		if (game_state->GetKey(GAMEKEY_JUMP)) {
			vel.SetY(JUMP_VELOCITY);
	  }	else {
			vel *= DRAG;
		}
	}

	// figure out whether to flip the sprite or not
	flip_x = false;

	if (accel.GetX() == 0.0f) {
		if (vel.GetX() > 0.0f) {
			flip_x = true;
		}
	} else if (accel.GetX() > 0.0f) {
		flip_x = true;
	} 
}

bool PlayerObject::Init(GameState* _game_state) {
	SetGameState(_game_state);
	return true;
}

PlayerObject::PlayerObject() {
}

PlayerObject::~PlayerObject() {}

//----------------------------
// objectPhysical.h
//----------------------------

// this file is a TEST ONLY

#ifndef PHYSICALOBJECT_H
#define PHYISCALOBJECT_H

#include <allegro.h>
#include <math.h>
#include <stdio.h>
#include <vector>

using namespace std;

class ObjectPhysical;

#include "globals.h"
#include "object.h"
#include "force.h"
#include "vector2D.h"

// directions

class PlayerObject : public Object {
	protected:
				
	public:
		void Solve();

		PlayerObject();
		~PlayerObject();
};

#endif // PLAYER_OBJECT_H

//----------------------------
// objectPhysical.cpp
//----------------------------

#include "objectPlayer.h"

void PlayerObject::Update() {	
	
	SetXY(20,30);

	/*int w = game_state->Width(), h = game_state->Height();
	BITMAP* dst_bitmap = game_state->GetDrawingSurface();*/
	
	/*
	x = vectors[_dX].CalcNextStep();
	y = -vectors[_dY].CalcNextStep();

	if (y > h - bitmap->h) {
			y = h - bitmap->h;
			vectors[_dY].position = -y;
	}
		
	vectors[_dX].v_decay = 1.00f;	// no decay in the air

	// if we're OK to jump now.. do it.
	if (y == h - bitmap->h) {
		vectors[_dX].v_decay = 0.99f;	// decay on the ground
		if (game_state->GetKey(GAMEKEY_JUMP)) {
			vectors[_dY].velocity = 10; // Rand(2,12);
	  }
	}
	
	if (x < 0) {
			vectors[_dX].position = x = 0;
			vectors[_dX].velocity = -vectors[_dX].velocity;
	}
	
	if (x > w - bitmap->w) {
			vectors[_dX].position = x = w - bitmap->w;
			vectors[_dX].velocity = -vectors[_dX].velocity;
	}*/
}

void PlayerObject::Draw() {
	
	bool flip = false;
	
	/*if (vectors[_dX].acceleration == 0) {
		if (vectors[_dX].velocity > 0) {
			flip = true;
		}
	} else if (vectors[_dX].acceleration > 0) {
		flip = true;
	} */

	if (flip)
		draw_sprite_h_flip(game_state->GetDrawingSurface(), bitmap, GetX(), GetY());
	else 
		draw_sprite(game_state->GetDrawingSurface(), bitmap, GetX(), GetY());
}

bool PlayerObject::Init(GameState* _game_state) {
	/*Force* force;*/

	SetGameState(_game_state);
	
	pos.Clear();
	vel.Clear();
	force.Clear();

	/*assert(GetGameState() != NULL);

	vectors[_dX].Clear();
	vectors[_dY].Clear();

	vectors[_dX].v_decay = 0.99f;

	force = new ForceInput();
	force->Init(GetGameState());
	vectors[_dX].Attach(force);

	force = new ForceGravity();
	force->Init(GetGameState());
	vectors[_dY].Attach(force);

	return true;
	*/
	return true;
}

PlayerObject::PlayerObject() {
}

PlayerObject::~PlayerObject() {}

//----------------------------
// objectIDs.h
//----------------------------

#ifndef OBJECT_IDS_H
#define OBJECT_IDS_H

// ID's of objects that you can create from the object factory
// NOTE: These are just examples for now, we'll replace them with real
// objects later on.

#define OBJECT_ID_RADIUS_BLOCK 	1
#define OBJECT_ID_PLAYER 2
#define OBJECT_ID_BACKGROUND 3

#endif // OBJECT_IDS_H

//----------------------------
// objectFactory.h
//----------------------------

#ifndef OBJECT_FACTORY_H
#define OBJECT_FACTORY_H

#include <allegro.h>
#include <stdio.h>

class ObjectFactory;

#include "globals.h"
#include "object.h"
#include "objectIDs.h"

#include "objectPlayer.h"
#include "objectRadiusBlock.h"
#include "objectBackground.h"

#include "gameBase.h"

#include "platform.h"

// THIS CLASS IS BAD.
// It will be rewritten, for now it JUST WORKS.
class ObjectFactory : GameBase {
	protected:

	public:
		int Init(GameState* _game_state);
		void Shutdown();

		Object* CreateObject(uint id);
		void DeleteObject(Object*);
		
		ObjectFactory();
		~ObjectFactory();
};

#endif // OBJECT_FACTORY_H

//----------------------------
// objectFactory.cpp
//----------------------------

#include "objectFactory.h"

// XXX NASTY!! SO BADLY WRITTEN, CLEAN IT UP
// break this up into smaller functions.. COME ON MORON!!X0r.
// ALSO, tons of memory leaks.  We will break this thing down
//  For now it 'just works'
Object* ObjectFactory::CreateObject(uint id) {
	
	Object* new_obj = NULL;
	RadiusBlockObject *rblock;
	PlayerObject *player;
	BackgroundObject *bg;
	ObjectProperties props;

	props.feels_gravity = 0;
	props.feels_user_input = 0;
	
	switch (id) {
		case OBJECT_ID_BACKGROUND:
			
			bg = new BackgroundObject(1.0f);
			if ( bg && bg->Init(GetGameState()) ) {
							
				PALETTE pal;
				BITMAP* bmp = load_bitmap(get_correct_path("data/back.tga"), pal);
				
				if (bmp) {

					set_palette(pal);

					bg->SetBitmapIsDeleteable(true);
					bg->SetBitmap(bmp);
					bg->SetXY(0, game_state->Height());
					bg->SetProperties(props);
					
				} else {
					fprintf(stderr, "ObjectFactory: Failed to load Player's bitmap - %s.\n", get_correct_path("data/back.tga"));
					if (bg) {
							free(bg);
							bg = NULL;
					}
				}
			} else {
				fprintf(stderr, "ObjectFactory: Failed to create Player object.\n");
				if (bg) {
						free(bg);
						bg = NULL;
				}	
			}

			new_obj = bg;
			break;

					
		case OBJECT_ID_RADIUS_BLOCK:
			
			rblock = new RadiusBlockObject();
			if ( rblock && rblock->Init(GetGameState()) ) {
							
				PALETTE pal;
				BITMAP* bmp = load_bitmap(get_correct_path("data/miroku.tga"), pal);
				
				if (bmp) {

					set_palette(pal);

					rblock->SetBitmapIsDeleteable(true);
					rblock->SetBitmap(bmp);
					rblock->SetXY(Rand(0, SCREEN_SIZE_X), Rand(0, SCREEN_SIZE_Y));
					rblock->SetTheta(Rand(0,360));
					rblock->SetRadius(Rand(20,300));
					rblock->SetProperties(props);
					
				} else {
					fprintf(stderr, "ObjectFactory: Failed to load Player's bitmap - %s.\n", get_correct_path("data/back.tga"));
					if (rblock) {
							free(rblock);
							rblock = NULL;
					}
				}
			} else {
				fprintf(stderr, "ObjectFactory: Failed to create Player object.\n");
				if (rblock) {
						free(rblock);
						rblock = NULL;
				}	
			}

			new_obj = rblock;
			break;
			
		case OBJECT_ID_PLAYER:
			
			player = new PlayerObject();

			if ( player && player->Init(GetGameState()) ) {
							
				PALETTE pal;
				BITMAP* bmp = load_bitmap(get_correct_path("data/kenshin.tga"), pal);
				
				if (bmp) {

					set_palette(pal);

					player->SetBitmapIsDeleteable(true);
					player->SetBitmap(bmp);
					player->SetX(20);
					player->SetY(80);
					player->SetMass(1.0f);

					props.feels_user_input = 1;
					props.feels_gravity = 1;
					props.feels_friction = 0;
					player->SetProperties(props);
					
				} else {
					fprintf(stderr, "ObjectFactory: Failed to create Sonic sprite's bitmap.\n");
					if (player) {
							free(player);
							player = NULL;
					}	
				}
		
			} else {
				fprintf(stderr, "ObjectFactory: Failed to create Sonic sprite.\n");
				if (player) {
						free(player);
						player = NULL;
				}
			}

			new_obj = player;
			break;

		default:
			fprintf(stderr, "ObjectFactory: Unknown ID passed: %i\n", id);
			new_obj = NULL;
	}
	
	return new_obj;
}

/*void ObjectFactory::DeleteObject(Object* obj) {
	obj->Delete();
	delete obj;
}*/

int ObjectFactory::Init(GameState* _game_state) {
	SetGameState(_game_state);
	return 0;
}

void ObjectFactory::Shutdown() {
}

ObjectFactory::ObjectFactory() {}
ObjectFactory::~ObjectFactory() {} 

//----------------------------
// objectBackground.h
//----------------------------

#ifndef BackgroundObject_H
#define BackgroundObject_H

#include <math.h>
#include <stdio.h>

class BackgroundObject;

#include "globals.h"
#include "object.h"

class BackgroundObject : public Object {
	protected:
		float scroll_offset;
		float speed;
				
	public:
		bool Init(GameState* _game_state);

		void Update();
		void Draw();

		BackgroundObject(float _speed = 0.5);
		~BackgroundObject();
};

#endif // BackgroundObject_H   

//----------------------------
// objectBackground.cpp
//----------------------------

#include "objectBackground.h"

void BackgroundObject::Update() {
	scroll_offset -= speed;
}

void BackgroundObject::Draw() {
	DrawAtOffset( int(scroll_offset) % bitmap->w, 0 );
	DrawAtOffset( int(scroll_offset) % bitmap->w + bitmap->w, 0 );
}

bool BackgroundObject::Init(GameState *_game_state) {
		SetGameState(_game_state);
		return true;
}

BackgroundObject::BackgroundObject(float _speed) {	
	speed = _speed;
	scroll_offset = 0.0f;
}

BackgroundObject::~BackgroundObject() {}

//----------------------------
// object.h
//----------------------------

// Object
// Base class for all objects displayable on the screen
// 
// TODO Replace BITMAP* sprite with animation class
#ifndef OBJECT_H
#define OBJECT_H

class Object;

#include <allegro.h>
#include <stdio.h>
#include <vector>
using namespace std;

typedef vector<Object*> ObjectList;

#include "globals.h"
#include "gameBase.h"
#include "vector2D.h"
#include "force.h"

//! A bit mask of various properties of an object
struct ObjectProperties {
	unsigned feels_gravity : 1;	
	unsigned feels_user_input : 1;
	unsigned feels_friction : 1;
};

//! An in-game object, can be affected by physical forces
class Object : public GameBase {
				
	protected:
		//! Current position
		Vector2D pos;

		//! Current velocity 
		Vector2D vel;

		//! Current force
		Vector2D accel;
		
		//! Object properties
		struct ObjectProperties properties;
		
		//! Bitmap to draw when this object is drawn
		BITMAP* bitmap;
		bool bitmap_is_deleteable;

		//! Whether to flip the sprite when drawing
		bool flip_x;
		bool flip_y;

		//! Object's Physical Mass
		float mass;

		//! Solve for the new position of this object
		Vector2D Solve();
		
	public:
		virtual bool Init(GameState* _game_state) = 0;
		virtual void Shutdown();
		
		virtual void Update() = 0;
		virtual void Draw();
		
		void DrawAtOffset(int x, int y);	// Draw this object at its coordinates
																			// plus this offset.
		
		void SetBitmap(BITMAP* _bitmap);
		
		void SetBitmapIsDeleteable(bool _is_deletable);
		bool GetBitmapIsDeleteable();
		
		inline int GetX() 					{ return (int)pos.GetX(); }
		inline int GetY() 					{ return (int)pos.GetY(); }
		inline void SetX(int _x) 		{ pos.SetX((float)_x); }
		inline void SetY(int _y) 		{ pos.SetY((float)_y);	}
		
		inline void SetXY(int _x, int _y) {
				pos.SetX((float)_x);	
				pos.SetY((float)_y);
		}
		
		inline int GetWidth() { return bitmap->w; }
		inline int GetHeight() {	return bitmap->h; }
	
		void ResetForNextFrame();
		void ApplyForce(Force* f);
		
		inline float GetMass() 					{ return mass; }
		inline void SetMass(float m) 		{ mass = m; }
		
		inline struct ObjectProperties GetProperties() { return properties; }
		inline void SetProperties(struct ObjectProperties p) { properties = p;}
		
		Object();
		virtual ~Object();
};

#endif // OBJECT_H

//----------------------------
// object.cpp
//----------------------------

#include "object.h"

// Putting this here is a nasty hack to avoid weird dependency loops
#include "gameState.h"

void Object::Draw() {
	DrawAtOffset(0,0);
}

void Object::DrawAtOffset(int _x, int _y) {	
	int x = int(pos.GetX()) + _x;
	int y = game_state->Height() - int(pos.GetY()) + _y;
	
	
	if (flip_x) 
		draw_sprite(game_state->GetDrawingSurface(), bitmap, x, y);
	else
		draw_sprite_h_flip(game_state->GetDrawingSurface(), bitmap, x, y);
}

void Object::Update() {
	// nothing to update for regular objects
}

void Object::SetBitmap(BITMAP* _bitmap) {
	bitmap = _bitmap;
}
				
void Object::SetBitmapIsDeleteable(bool _bitmap_is_deleteable) {
	bitmap_is_deleteable = _bitmap_is_deleteable;
}

bool Object::GetBitmapIsDeleteable() {
	return bitmap_is_deleteable;
}

void Object::Shutdown() {
	if (bitmap_is_deleteable) 
		destroy_bitmap(bitmap);

	bitmap = NULL;
}

void Object::ApplyForce(Force* force) {
	// ignore certain types of forces
	if (	(!properties.feels_gravity && force->GetType() == FORCE_GRAVITY) ||
				(!properties.feels_user_input && force->GetType() == FORCE_INPUT) ||
				(!properties.feels_friction && force->GetType() == FORCE_FRICTION) )
		return;
	else
		accel += force->GetForce(this) / mass;
}

void Object::ResetForNextFrame() {
	accel.Clear();
}

//! Solve for new position based on velocity
Vector2D Object::Solve() {
	Vector2D newpos = pos;

	vel += accel;
	newpos += vel;

	return newpos;
}

Object::Object() : bitmap(NULL), bitmap_is_deleteable(false), 
									 flip_x(false), mass(1.0f)  {}
Object::~Object() {}

//----------------------------
// main.cpp
//----------------------------

#include <allegro.h>
#include <stdio.h>

#include "gameState.h"
#include "gameOptions.h"

/// The main function
/// IT ROCKS
int main(int argc, char* argv[]) {

	// see if our command line args are OK
	GameOptions options;
	options.PrintBanner();
	options.ParseArguments(argc, argv);
	options.PrintOptions(argv[0]);

	if (!options.IsValid())	{
		return -1;
	} else {
		// if OK, run the actual game
		GameState gameState;
		return gameState.RunGame(&options);
	}

} END_OF_MAIN();

//----------------------------
// inputRecord.h
//----------------------------

/* Live Input 
 *
 * Repsonsible for handling 'live' input (keyboard, mouse, etc)
 */

#ifndef InputRecordHANDLER_H
#define InputRecordHANDLER_H

#include <allegro.h>
#include <stdio.h>

class InputRecord;

#include "globals.h"
#include "input.h"
#include "gameState.h"

//! Live input 

//! Reads input devices in realtime (used for normal game play)
class InputRecord : public BaseInput {
	
	protected:
		//! The current demo file being written
		FILE* demofile;
		
		//! The last state of the keys
		int old_key[GAMEKEY_COUNT];
		
		//! The frame count we are on [updated by Update()]
		unsigned long frame_counter;

		bool InitRecorder(char* filename);
	
	public:
		int Init(GameState* _game_state, char* _demo_file = NULL);
		void Shutdown();

		void Update();
		
		void BeginRecording();
		void EndRecording();

		void BeginPlayback()	{NotSupported();}
		void EndPlayback()	{NotSupported();}

		InputRecord();
		~InputRecord();
};

#endif // InputRecordHANDLER_H

//----------------------------
// inputRecord.cpp
//----------------------------

#include "inputRecord.h"

int InputRecord::Init(GameState* _game_state, char* _demo_file) {

	if (!_demo_file) {
		fprintf(stderr, "InputRecord: ERROR: No demo filename passed. "
										"Required for input recording.\n");
		return -1;
	} 
				
	SetGameState(_game_state);
				
	install_mouse();
	install_keyboard();
	
	LoadDefaultKeyMappings();

	if (InitRecorder(_demo_file))
		return 0;
	else 
		return -1;
}

void InputRecord::Shutdown() {
	remove_mouse();
	remove_keyboard();

	if (demofile) {
		fprintf(stderr, "WARN: closing demofile (currently in progress)");
		fclose(demofile);
	}
}

//! Update the state of the input

//! This is A little complicated..
//! First we save the old keys being pressed.
//! Then we get the new keys being pressed.
//! If anything is different, write it to the demo with the frame counter
void InputRecord::Update() {
	
	uint i;
	bool keys_changed = false;
	
	// TODO: check to make sure this doesn't get too big.
	frame_counter++;
	
	for (i = 0; i < GAMEKEY_COUNT; i++) {
		// Save the old keys
		old_key[i] = game_key[i];

		// Get new keys
		if ( key[gamekey_to_realkey[i]] )
			game_key[i] = 1;
		else 
			game_key[i] = 0;

		// Output any differences between the old keys and the new keys to a file
		if ( demofile && (old_key[i] != game_key[i]) ) {
				if (!keys_changed) {
						fprintf(demofile, "%lu", frame_counter);
						keys_changed = true;
				}

				// remember, we are writing out GAMEKEYs not REAL keys.
				// e.g. KEY_JUMP, not KEY_SPACEBAR
				fprintf(demofile, " %u %u", i, game_key[i]);
		}
	}
	
	if (keys_changed && demofile) {
			fprintf(demofile, "\n");
	}
}

bool InputRecord::InitRecorder(char* filename) {
	
	if (demofile) {
		fprintf(stderr, "InputRecord: ERROR already saving demo file.\n");
		return false;
	} 

	demofile = fopen(filename, "w");
	
	if (!demofile) {
			fprintf(stderr,	"InputRecord: ERROR can't write to demofile '%s'.\n",
							filename);
			return false;
	}

	fprintf(stderr, "InputRecord: Recording demo to file '%s'.\n", filename);

	// write 'DEMO' header + game version number and some extra info
	fprintf(demofile, "DEMO:ninja-engine saved demo file:%s:%s\n",
										VERSION_STRING, ALLEGRO_PLATFORM_STR);
	
	// write the current random seed
	fprintf(demofile, "%i\n", GetGameState()->GetRandomSeed() );
	
	return true;
}

void InputRecord::BeginRecording()	{
				
	if (!demofile) {
		fprintf(stderr,	"InputRecord: ERROR InitRecorder() not called yet!\n");
		return;
	}
	
	ClearKeys();
	ClearKeys(old_key);

	frame_counter = 0;
}

void InputRecord::EndRecording()	{
	fclose(demofile);
	demofile = NULL;
}

InputRecord::InputRecord() : demofile(NULL) {}
InputRecord::~InputRecord() {}

//----------------------------
// inputPlayback.h
//----------------------------

/* Live Input 
 *
 * Repsonsible for handling 'live' input (keyboard, mouse, etc)
 */

#ifndef InputPlaybackHANDLER_H
#define InputPlaybackHANDLER_H

#include <allegro.h>
#include <stdio.h>

class InputPlayback;

#include "globals.h"
#include "input.h"
#include "gameState.h"

//! Playback recorded input

//! Reads input devices in realtime (used for normal game play)
class InputPlayback : public BaseInput {
	
	protected:
		//! The current demo file being read from
		FILE* demofile;
		
		//! The frame count we are on [updated by Update()]
		unsigned long frame_counter;

		bool InitPlayback(char* filename);

		//! The next frame for which we have data
		unsigned long next_frame_num;
		int next_frame_data[GAMEKEY_COUNT];

		//! True if we are at the end of this file
		bool at_eof;

		//! Reads the next frame from a file
		void GetNextFrameData();

		//! Uses the new frame data as the current data
		void UseNextFrameData();

	public:
		int Init(GameState* _game_state, char* _demo_file = NULL);
		void Shutdown();

		void Update();
		bool Key(uint gameKey);
		
		void BeginPlayback();
		void EndPlayback();

		void BeginRecording() {NotSupported();}
		void EndRecording() {NotSupported();}

		InputPlayback();
		~InputPlayback();
};

#endif // InputPlaybackHANDLER_H

//----------------------------
// inputPlayback.cpp
//----------------------------

#include "inputPlayback.h"

int InputPlayback::Init(GameState* _game_state, char* _demo_file) {
	SetGameState(_game_state);
				
	LoadDefaultKeyMappings();

	if (_demo_file)
		if( InitPlayback(_demo_file) )
			return 0;
		else 
			return -1;
	else 
		return 0;
}

bool InputPlayback::InitPlayback(char* filename) {

	const uint BUF_SIZE = 256; 
	char line2[256];
	bool error = false;

	at_eof = false;
	uint seed;
				
	if (demofile) {
		fprintf(stderr, "InputPlayback: ERROR already reading demo file.\n");
		return false;
	} 

	demofile = fopen(filename, "r");
	
	if (!demofile) {
			fprintf(stderr,	"InputPlayback: ERROR can't open demofile '%s'.\n",
							filename);
			return false;
	}
	
	fprintf(stderr, "InputRecord: Playing back demo from file '%s'.\n", filename);

	// 1st line2: 'DEMO' header + version info
	// (todo.. we could check for engine version numbers in this line2)
	if ( error	|| !fgets(line2, BUF_SIZE, demofile) 
							|| strncmp(line2, "DEMO", 4) != 0 )
		error = true;

	// 2nd line2, random seed
	if ( error	|| !fgets(line2, BUF_SIZE, demofile)
							|| sscanf(line2, "%u\n", &seed) != 1) {
		error = true;
	} else {
		GetGameState()->SetRandomSeed(seed);
		fprintf(stderr, "InputPlayback: Using random seed %u\n", seed);
	}

	if (error) {
		fclose(demofile);
		demofile = NULL;
		at_eof = true;
	}

	frame_counter = 0;
	
	ClearKeys();
	ClearKeys(next_frame_data);
	GetNextFrameData();

	return error;
}

// pass key_buffer = NULL in order to use the default key buffer
// (which is usually what you want)
void InputPlayback::UseNextFrameData() {	
	uint i;
	for (i = 0; i < GAMEKEY_COUNT; i++) {
		game_key[i] = next_frame_data[i];
	}
}

//! Reads the next frame from the demo file.  Closes the
//! file if we are at the end of file.
void InputPlayback::GetNextFrameData() {
	const uint BUF_SIZE = 512;
	char buf[BUF_SIZE];
	char *s = buf;
	bool error = false;	

	uint next_frame;
	uint key, value;
	uint count = 0;

	if (!demofile || at_eof)
		return;
	
	if (!fgets(buf, BUF_SIZE, demofile)) {
		at_eof = true;
		return;
	}
	
	// the file format is like this:
	// "frame_number key1 value1 [key2] [value2]\n"
	
	// read the frame number
	count = sscanf(buf, "%u", &next_frame);
	if (count != 1 || next_frame <= frame_counter)
		error = true;
		
	// go to next space
	if (error || (s = strchr(buf, ' ')) == NULL)
		error = true;
	else
		next_frame_num = next_frame;
			
	// read each key,value pair,
	// overwrite existing values in next_data_
	count = 2;
	while (!error && count == 2 && s) {
						
		s++;	// skip over current space
		count = sscanf(s, "%u %u", &key, &value);
			
		if (count == 2) {
			next_frame_data[key] = value;

			// skip 2 spaces
			s = strchr(s, ' ');
			if (s) 
				s = strchr(s+1, ' ');	// will be NULL at end of the line
			else
				count = 1;						// fall through to error handler
		}
			
		if (count == 1) {
			// total badness.. we need to handle this better,
			// but just DIE right here.
			fprintf(stderr, "HUGE HUGE INTERNAL ERROR: Could only read one value\n"
											"from the demo file, it is probably corrupted.\n");
			error = true;
			exit(-1);
		}
			
	}	
}

//! Update the state of the input
void InputPlayback::Update() {
	
	// TODO: check to make sure this doesn't get too big.
	frame_counter++;

	if (frame_counter == next_frame_num && !at_eof) {
			UseNextFrameData();	
			GetNextFrameData();
	}	
}

void InputPlayback::BeginPlayback()	{
				
	ClearKeys();

	if (!demofile) {
		fprintf(stderr,	"InputPlayback: ERROR InitRecorder() not called yet!\n");
		return;
	}	

	frame_counter = 0;
}

void InputPlayback::EndPlayback()	{
	fclose(demofile);
	demofile = NULL;
}

void InputPlayback::Shutdown() {
	if (demofile) {
		fprintf(stderr, "WARN: closing demofile (currently in progress)");
		fclose(demofile);
		demofile = NULL;
	}
}

InputPlayback::InputPlayback() : demofile(NULL) {}
InputPlayback::~InputPlayback() {}

//----------------------------
// inputLiveHandler.h
//----------------------------

/* Live Input 
 *
 * Repsonsible for handling 'live' input (keyboard, mouse, etc)
 */

#ifndef INPUTLIVEHANDLER_H
#define INPUTLIVEHANDLER_H

#include <allegro.h>
#include <stdio.h>

class InputLive;

#include "globals.h"
#include "input.h"

//! Live input 

//! Reads input devices in realtime (used for normal game play)
class InputLive : public BaseInput {
	
	protected:
	
	public:
		int Init(GameState* _game_state, char* _demo_file = NULL);
		void Shutdown();

		void Update();
				
		bool Key(uint gameKey);

		void BeginRecording()	{NotSupported();}
		void EndRecording()	{NotSupported();}
		void BeginPlayback()	{NotSupported();}
		void EndPlayback()	{NotSupported();}
		void SaveRandomSeed()	{NotSupported();}
		void GetRandomSeed()	{NotSupported();}

		InputLive();
		~InputLive();
};

#endif // INPUTLIVEHANDLER_H

//----------------------------
// inputLiveHandler.cpp
//----------------------------

#include "inputLiveHandler.h"

int InputLive::Init(GameState* _game_state, char* _demo_file) {

	if (_demo_file) {
		fprintf(stderr, "ERROR: Can't use a demo file with Live Input.\n");
		return -1;
	}
				
	SetGameState(_game_state);
				
	install_mouse();
	install_keyboard();
	
	LoadDefaultKeyMappings();
	return 0;
}

void InputLive::Shutdown() {
	remove_mouse();
	remove_keyboard();
}

//! Input update (freeze state of input)

//! freeze the current state of the input into gamekey[].
//! key[] is from allegro, it is the current state of what 
//! is currently being pressed
void InputLive::Update() {
	uint i;
	for (i = 0; i < GAMEKEY_COUNT; i++) {
		game_key[i] = key[gamekey_to_realkey[i]];
	}
}

InputLive::InputLive() {}
InputLive::~InputLive() {}

//----------------------------
// input.h
//----------------------------

/* Input Base Class
 *
 * The only reason for having a base class is
 * to make derived classes - one which can do 
 * real input live from keyboard, mouse, or joystick
 * and the other class to be able to record the input
 * and play it back for the sake of a demo game.
 *
 * The underlying game should not notice the difference
 * between live and recorded stuff.
 */

#ifndef INPUT_H
#define INPUT_H

#include <allegro.h>

class BaseInput;

#include "globals.h"
#include "gameBase.h"

//! The logical game keys (e.g. JUMP, FIRE, etc)
#define GAMEKEY_JUMP 		0
#define GAMEKEY_LEFT		1	
#define GAMEKEY_RIGHT		2
#define GAMEKEY_UP			3
#define GAMEKEY_DOWN		4
#define GAMEKEY_EXIT		5

#define GAMEKEY_COUNT 	6

//! Base input class

//! The base input class is used for 3 classes:
//! The LiveInput class, the RecordInput class, and
//! PlaybackInput class.
//! -
//! Every frame, Update() MUST be called.  This freezes the
//! current state of the buttons/mouse for this frame.  This is
//! extremely important, especially for the demos, to make sure 
//! input values do NOT change between frames.  
//! -
//! If the derived class is LiveInput then the input Live from the 
//! input devices will be show
//! -
//! If the derived class is RecordInput, it will save the state of
//! the input devices at EVERY frame on Update() to a file.
//! -
//! If the derived class is PlaybackInput, it will load the state
//! of the keys from a file each frame on Update().
//! -
//! Don't forget to save the random seed in this class, otherwise demos
//! will not play back correctly.
class BaseInput : public GameBase {
	protected:
		//! The keys currently being pressed (e.g. GAMEKEY_JUMP)
		int game_key[GAMEKEY_COUNT];

		//! The mapping of real keys to gamekeys (e.g. SPACE to GAMEKEY_JUMP)
		int gamekey_to_realkey[GAMEKEY_COUNT];
		
		//! Load the default key mappings
		void LoadDefaultKeyMappings();
		
		//! Load key mappings from a file
		bool LoadKeyMappings(char* filename);

		//! Zero out the keyboard buffer
		void ClearKeys(int *key_buffer = NULL);
		
	public:
		//! Init the input system
		virtual int Init(GameState* _game_state, char* _demo_file = NULL) = 0;

		//! Shutdown the input system
		virtual void Shutdown() = 0;

		//! Update the inputs (mice/keys)
		virtual void Update() = 0;
		
		//! Get the status of a key 
		bool Key(uint gameKey);

		//! Get the mouse X coordinate
		// virtual int MouseX() = 0;

		//! Get the mouse Y coordinates
		// virtual int MouseY() = 0;
		
		//! RECORD: Begin recording input (for demos)
		virtual void BeginRecording() = 0;

		//! RECORD: End Recording input (for demos)
		virtual void EndRecording() = 0;
		
		//! PLAYBACK: Begin playback of input (for demos)
		virtual void BeginPlayback() = 0;

		//! PLAYBACK: End playback of input (for demos)
		virtual void EndPlayback() = 0;

		BaseInput();
		virtual ~BaseInput() = 0;
};

#endif // INPUT_H

//----------------------------
// input.cpp
//----------------------------

#include "input.h"

// default game keys, failsafes only
#define DEFAULT_GAMEKEY_JUMP	KEY_SPACE
#define DEFAULT_GAMEKEY_EXIT	KEY_ESC
#define DEFAULT_GAMEKEY_LEFT	KEY_LEFT
#define DEFAULT_GAMEKEY_RIGHT 	KEY_RIGHT
#define DEFAULT_GAMEKEY_UP 	KEY_UP
#define DEFAULT_GAMEKEY_DOWN	KEY_DOWN

// pass key_buffer = NULL in order to use the default key buffer
// (which is usually what you want)
void BaseInput::ClearKeys(int* key_buffer) {

	if (!key_buffer)
		key_buffer = game_key;
		
	uint i;
	for (i = 0; i < GAMEKEY_COUNT; i++) {
		key_buffer[i] = 0;
	}
}

bool BaseInput::Key(uint gameKey) {
	return game_key[gameKey];
}

void BaseInput::LoadDefaultKeyMappings() {
	fprintf(stderr, "BaseInput: Using default key mappings!\n");
	
	gamekey_to_realkey[GAMEKEY_JUMP] = DEFAULT_GAMEKEY_JUMP;
	gamekey_to_realkey[GAMEKEY_EXIT] = DEFAULT_GAMEKEY_EXIT;
	gamekey_to_realkey[GAMEKEY_LEFT] = DEFAULT_GAMEKEY_LEFT;
	gamekey_to_realkey[GAMEKEY_RIGHT]= DEFAULT_GAMEKEY_RIGHT;
	gamekey_to_realkey[GAMEKEY_UP] 	 = DEFAULT_GAMEKEY_UP;
	gamekey_to_realkey[GAMEKEY_DOWN] = DEFAULT_GAMEKEY_DOWN;

	ClearKeys();
}

bool BaseInput::LoadKeyMappings(char* filename) {
	fprintf(stderr, "BaseInput: Key map loading not supported yet!\n");
	return false;
}

BaseInput::BaseInput() {}
BaseInput::~BaseInput() {}

//----------------------------
// globals.h
//----------------------------

/* Global vars/defines */

#ifndef GLOBALS_H
#define GLOBALS_H

// include master config.h from ./configure script
#include <config.h>
#include <assert.h>
#include <stdio.h>

typedef unsigned int uint;

// lameass .dat file functions
//#define E(x) ((BITMAP*)e[x].dat)
//#define S(x) ((BITMAP*)s[x].dat)
//#define SOUNDS(x) ((SAMPLE*)sounds[x].dat)

#define Rand(lower, upper) \
((rand() % (upper - lower + 1)) + lower)

//#define SCREEN_SIZE_X	640
//#define SCREEN_SIZE_Y 480

#define SCREEN_SIZE_X	320
#define SCREEN_SIZE_Y 200

// full version string 
#define VERSION_STRING PACKAGE"-"VERSION

// the fps (not ever changed)
// timestep is 1/FPS
#define FPS 30
#define TIMESTEP 1/FPS

#endif // GLOBALS_H

//----------------------------
// gameState.h
//----------------------------

#ifndef GAMESTATE_H
#define GAMESTATE_H

#include <allegro.h>
#include <stdio.h>
#include <vector>

using namespace std;

class GameState;

#include "globals.h"
#include "gameOptions.h"
#include "timer.h"
#include "input.h"
#include "inputLiveHandler.h"
#include "inputRecord.h"
#include "inputPlayback.h"
// #include "object.h"
// #include "objectFactory.h"
#include "window.h"
#include "physSimulation.h"

class Window;

//! Represents the current state of the game.

//! This is the 'main object' for the game - the centrally
//! coordinated object which initializes, runs, and destroys
//! the entire game.  Anything of importance starts in this
//! class somewhere.
class GameState {
	protected:

		//! Random seed for the game
		int random_seed;
					
		//! Options parsed from the commandline
		GameOptions *options;
		
		//! The game's on-screen window
		Window *window;								
				
		//! Active input module
		BaseInput *input;

		//! The physics simulation
		PhysSimulation *simulation;

		//! Collection of all drawable objects
		//vector<Object*> objects;

		//! Collection of forces
		// vector<Force*> forces;
	
		//! Set this to TRUE to exit the game 
		bool exit_game;
			
		//! The state of the game engine
		enum state {
			STATE_NORMAL,
			STATE_PAUSED
		};
					
		int InitSystem();
		
		int InitTimers();
		int InitInput();
		// int InitSimulation();
		
		// void DestroyObjects();
		
		void Shutdown();

		void MainLoop();

		void Update();
		void Draw();

				
	public:
		int RunGame(GameOptions *_options);

		// no one uses these (rv90)
		// inline GameOptions* 	GetGameOptions() 		{ return options; };
		// inline ObjectFactory*	GetObjectFactory()	{ return objectFactory; };

		inline void SetRandomSeed(int val)		{ random_seed = val; srand(val); };
		inline int GetRandomSeed()						{ return random_seed; };

		//! Get status of a key
		inline bool GetKey(uint which_key)				{ return input->Key(which_key); };

		//! Get drawing surface (essentially the screen)
		BITMAP* GetDrawingSurface();
		uint Width();
		uint Height();

		GameState();
		~GameState();
};

#endif

//----------------------------
// gameState.cpp
//----------------------------

#include "gameState.h"

//! Get the drawing surface (effectively the screen)
// THIS FUNCTION CAN'T BE INLINED (easily) due to dependency wack-ness
BITMAP* GameState::GetDrawingSurface() { 
	return window->GetDrawingSurface(); 
};

uint GameState::Width() {
	return window->Width();
}

uint GameState::Height() {
	return window->Height();
}

//! Initialize game systems - main function

//! This is the first init function, it needs to initialize
//! Allegro, the window, the input subsystem, and the simulation
//! BE CAREFUL, things need to be done IN ORDER here.
int GameState::InitSystem() {

		exit_game = false;

		allegro_init();
		InitTimers();

		SetRandomSeed(42);

		window = new Window();
		if ( !window ||	window->Init(this, 640, 480, 
										options->IsFullscreen(), options->GraphicsMode()) < 0 ) {
			fprintf(stderr, "ERROR: InitSystem: failed to init window!\n");
			return -1;
		}

		if (InitInput() == -1) {
			fprintf(stderr, "ERROR: InitSystem: failed to init input subsystem!\n");
			return -1;
		}
		
		simulation = new PhysSimulation();
		if ( !simulation || simulation->Init(this) < 0) {
			fprintf(stderr, "ERROR: InitSystem: failed to init simulation!\n");
			return -1;
		}
					
		return 0;
}

//! Init input subsystems
int GameState::InitInput() {
				
	// init the right kind of class based on
	// whether or not we are recording/playing back a demo
	if ( options->RecordDemo() )
		input = new InputRecord();	
	else if ( options->PlaybackDemo() )
		input = new InputPlayback();
	else
		input = new InputLive();

	
	if ( !input || !input->Init(this, options->GetDemoFilename()) < 0 ) {
		return -1;
	}

	return 0;
}

//! Init game timers

//! This MUST be called BEFORE any other allegro initializations.
int GameState::InitTimers() {
	install_timer();
	LOCK_VARIABLE(outstanding_updates);
	LOCK_FUNCTION((void*)Timer);
	return install_int_ex(Timer, BPS_TO_TIMER(FPS));
}

//! Initialize game objects

//! Uses the objectFactory to create some random objects.
//int GameState::InitSimulation() {
//}

//! The 'main' function for the game

//! It takes a pointer to the game options (fullscreen/etc).
//! It initializes everything, and returns 0 if successful
//! or 1 on error.
int GameState::RunGame(GameOptions* _options) {
		
		options = _options;
		
		if (InitSystem() == -1) {
			fprintf(stderr, "ERROR: Failed to init game!\n");
			return -1;	
		} else {
	
			// XXX SHOULD NOT TEST option->is_xxx should TEST input->is_xxx()
			if (options->RecordDemo())
				input->BeginRecording();
			else if (options->PlaybackDemo())
				input->BeginPlayback();
			
			outstanding_updates = 0;	// remember, the timer has been rolling.
			MainLoop();

			// XXX SHOULD NOT TEST option->is_xxx should TEST input->is_xxx()
			if (options->RecordDemo())
				input->EndRecording();
			else if (options->PlaybackDemo())
				input->EndPlayback();
		}
	
		Shutdown();

		return 0;
}

//! The Main Loop

//! The most important function.  It will make sure that the game 
//! is updating at the correct speed, and it will Draw everything
//! at the correct speed.
void GameState::MainLoop() {
				
	while (!exit_game) {

		// outstanding_updates is incremented once every 1/60th of a sec.
		// We may need to update more than once on slower computers
		// before we can draw, in order to keep the game the same speed
		// no matter the speed of the computer
		while (outstanding_updates > 0) {
			Update();
			outstanding_updates--;
		}
		Draw();

		// wait for 1/60th sec to elapse (if we're on a fast computer)
		while (outstanding_updates <= 0);
  }
}

//! Update all game status

//! Call update on all objects to let them know
//! how much time has passed.
void GameState::Update() {
	input->Update();
	simulation->Update();

	if (input->Key(GAMEKEY_EXIT)) {
		exit_game = true;
	}
}

//! Draw all game objects

//! Loop through and draw all game objects.
void GameState::Draw() {
	window->Clear();
	simulation->Draw();
	window->Flip();
}

//! Shutdown the game

//! Clean up everything we allocated
void GameState::Shutdown() {

	if (simulation) {
		simulation->Shutdown();
		delete simulation;
		simulation = NULL;
	}
				
	if (input) {
		input->Shutdown();
		delete input;
		input = NULL;
	}
		
	// window destruction code must be LAST
	if (window) {
		window->Shutdown();
		delete window;
		window = NULL;
	}
		
	allegro_exit();
}

//! Destory all game objects

//! Clean up everything we allocated
//void GameState::DestroyObjects() {
//}

GameState::GameState() : 
window(NULL), input(NULL), simulation(NULL) {}
GameState::~GameState() {}

//----------------------------
// gameOptions.h
//----------------------------

// reads command line arguments and parse them

#ifndef ARGS_H
#define ARGS_H

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

class GameOptions;

#include "globals.h"

class GameOptions {
	protected:
		bool is_valid;
		
		bool show_help;
		bool fullscreen;
	
		bool record_demo;
		bool playback_demo;
		char* demo_filename;

		int graphics_mode;
		
	public:
		void PrintOptions(char* arg0);
		void PrintBanner();

		bool ParseArguments(int argc, char* argv[]);
		bool IsValid();
		void Clear();

		inline bool IsFullscreen() {return fullscreen;};
		inline char* GetDemoFilename() {return demo_filename;};
		inline bool RecordDemo() {return record_demo;};
		inline bool PlaybackDemo() {return playback_demo;};
		inline int GraphicsMode() {return graphics_mode;};

		GameOptions();
		~GameOptions();
};

#endif // ARGS_H

//----------------------------
// gameOptions.cpp
//----------------------------

#include "gameOptions.h"
#include "basename.h"

void GameOptions::PrintBanner() {
		fprintf(stderr, 
		"Ninja Engine (%s)\n"
		"binary1230(at)yahoo.com | http://einsteinsbreakfast.com\n"
		"(c) 2005 Dominic Cerquetti, this program is Free Software\n"
		"Licensed under the GNU GPL v2, see http://gnu.org\n\n",
		VERSION_STRING);
}

void GameOptions::PrintOptions(char* arg0) {
	arg0 = basename(arg0);
	if (!show_help) {
		fprintf(stderr, "type '%s -h' for more options..\n\n", arg0);
	} else {
		fprintf(stderr,
		"NOTE: .dat files MUST be in a dir in THIS folder called 'data'\n\n"

		"Usage: %s [options]\n"
		"-f            | try to force fullscreen mode\n"
		"-w            | try to force windowed mode\n"
		"-g mode       | 0 = no buffering, 1 = double buffer [default]\n"
		"              | 2 = page flipping, 3 = triple buffering\n\n"
		
		"-r file       | record a demo to 'file'\n"
		"-p file       | playback a demo from 'file'\n\n"

		"-h            | display this help message\n\n"
		, arg0);
	}
}

void GameOptions::Clear() {
	fullscreen = false;
	show_help = false;

	record_demo = false;
	playback_demo = false;
	
	demo_filename = NULL;

	graphics_mode = 1;	// XXX magic number. get it from window.h

	is_valid = true;
}

bool GameOptions::ParseArguments(int argc, char* argv[]) {
	
	char c;
	char* buffer;
	bool _fullscreen_option_set = false;

	Clear();

	while ( (c = getopt(argc,argv,"g:r:p:fwh")) != -1) {
		switch (c) {

			// get demo filename
			case 'r': case 'p':
				if (demo_filename) {
						fprintf(stderr,	"Options ==> ERROR "
														"Don't give more than 1 demo filename (-r, -p)\n");
						return (is_valid = false);
				}

				if (c == 'r')
						record_demo = true;
				else 
						playback_demo = true;
								
				buffer = new char[strlen(optarg) + 1];
				demo_filename = strcpy(buffer, optarg);
				break;
			
			// display help
			case 'h':
				show_help = true;
				return (is_valid = false);
				break;
	
			// fullscreen or windowed
			case 'f': case 'w':
				if (_fullscreen_option_set) {
					fprintf(stderr,"Options ==> ERROR, Cannot select both fullscreen (-f) and windowed (-w) mode.\n");
					return (is_valid = false);
				} else if (c == 'f') {
					fullscreen = true;
					_fullscreen_option_set = true;
					fprintf(stderr, "Options ==> fullscreen mode enabled\n");
				} else if (c == 'w') {
					fullscreen = false;
					_fullscreen_option_set = true;
					fprintf(stderr, "Options ==> windowed mode enabled\n");
				}
				break;

			case 'g':
				graphics_mode = strtoul(optarg, NULL, 10);
				// XXX Magic number.  #define u twit.
				if (graphics_mode >= 4 || graphics_mode < 0) {
					fprintf(stderr, "ERROR: Graphics mode is out of range.\n");
					show_help = true;
					return (is_valid = false);
				}
				break;
	
			// : and ? mean something is weird
			default:
			case ':': case '?':
				fprintf(stderr, "Unrecognized command line option '-%c'\n", c);
				show_help = true;
				return (is_valid = false);
				break;
		}
	}
	return IsValid();
}

bool GameOptions::IsValid() {
	return is_valid;
}

GameOptions::~GameOptions() {
	if (demo_filename)
		delete demo_filename;
}

GameOptions::GameOptions() : demo_filename(NULL) {}

//----------------------------
// gameBase.h
//----------------------------

#ifndef GAMEBASE_H
#define GAMEBASE_H

#include <stdio.h>

//! Really generic base class for all game classes

class GameState;

class GameBase {
		protected:
			GameState* game_state;
	
		public:
			inline GameState* GetGameState() {
				return game_state;
			};

			inline void SetGameState(GameState* _game_state) {
				game_state = _game_state;
			};

			//! Display 'not supported'
			inline bool NotSupported() {
				fprintf(stderr, "Not supported.\n");
				return false;
			}

			GameBase();
			virtual ~GameBase();
};

#endif //  GAMEBASE_H

//----------------------------
// gameBase.cpp
//----------------------------

#include "gameBase.h"

GameBase::GameBase() : game_state(NULL) {}
GameBase::~GameBase() {}

//----------------------------
// forceInput.h
//----------------------------

/* Forces: Gravity
 * all time increments are 1/60th of a second */

#ifndef FORCEINPUT_H
#define FORCEINPUT_H

#include <allegro.h>

class Force;
class ForceInput;

#include "globals.h"
#include "force.h"
#include "input.h"
#include "gameState.h"

class ForceInput : public Force {
	public:
		Vector2D GetForce(Object*);

		ForceInput();
		virtual ~ForceInput();
};

#endif // FORCEINPUT_H

//----------------------------
// forceInput.cpp
//----------------------------

#include "forceInput.h"

#define MAGNITUDE 10.0f

Vector2D ForceInput::GetForce(Object* obj) {
				
	if (!GetGameState()) {
			fprintf(stderr, "Gamestate is NULL??\n");
			abort();
	}

	// return a force based on 2 inputs.
	if (game_state->GetKey(GAMEKEY_LEFT)) 
		return Vector2D(-MAGNITUDE * TIMESTEP, 0.0f);

	else if (game_state->GetKey(GAMEKEY_RIGHT))
		return Vector2D( MAGNITUDE * TIMESTEP, 0.0f);

	else
		return Vector2D( 0.0f, 0.0f);	

}

ForceInput::ForceInput() {
	type = FORCE_INPUT;
}

ForceInput::~ForceInput() {}

//----------------------------
// forceGravity.h
//----------------------------

/* Forces: Gravity
 * all time increments are 1/60th of a second */

#ifndef FORCEGRAV_H
#define FORCEGRAV_H

class ForceGravity;
class Force;

#include "globals.h"
#include "force.h"

class ForceGravity : public Force {
	protected:
		float gravitational_constant;
		
	public:
		Vector2D GetForce(Object*);

		ForceGravity(float _magnitude = -9.81f);
		virtual ~ForceGravity();
};

#endif // FORCEGRAB_H

//----------------------------
// forceGravity.cpp
//----------------------------

#include "forceGravity.h"

/* note: if you are trying to figure out the engine, this file is pretty easy
 * to understand */

Vector2D ForceGravity::GetForce(Object* obj) {
		
		// we need to return the vector representing the force of gravity 
		// acting on this object in a given amount of time (the TIMESTEP)
		
		// the formula:
		//  gravitational_constant = -9.81 m/sec^2 (on earth)
		//  force = mass_of_object * gravitational_constant 
		
		float force = gravitational_constant * obj->GetMass() * TIMESTEP;
		return Vector2D(0.0f, force); 
}

ForceGravity::ForceGravity(float _gravitational_constant) {
	gravitational_constant = _gravitational_constant;
	type = FORCE_GRAVITY;
}

ForceGravity::~ForceGravity() {}

//----------------------------
// forceFactory.h
//----------------------------

#ifndef FORCE_FACTORY_H
#define FORCE_FACTORY_H

#include <allegro.h>
#include <stdio.h>

class ForceFactory;

#include "globals.h"
#include "gameBase.h"

#include "force.h"
#include "forceInput.h"
#include "forceGravity.h"

#include "platform.h"

// THIS CLASS IS BAD.
// It will be rewritten, for now it JUST WORKS.
class ForceFactory : GameBase {
	protected:

	public:
		int Init(GameState* _game_state);
		void Shutdown();

		Force* CreateForce(ForceType type);
		void DeleteForce(Force*);
		
		ForceFactory();
		~ForceFactory();
};

#endif // FORCE_FACTORY_H

//----------------------------
// forceFactory.cpp
//----------------------------

#include "forceFactory.h"

// XXX NASTY!! SO BADLY WRITTEN, CLEAN IT UP
Force* ForceFactory::CreateForce(ForceType type) {
	
	Force* force = NULL;
	ForceInput* inputForce;
	ForceGravity* gravityForce;
	
	switch (type) {
		case FORCE_INPUT:
	
			inputForce = new ForceInput();
			if ( inputForce && inputForce->Init(GetGameState()) ) {

				// Initialize it here
				// inputForce->SetSomething(...)
			
			} else {
				fprintf(stderr, "ForceFactory: Failed to create new Input Force\n");
				if (inputForce) {
						free(inputForce);
						inputForce = NULL;
				}	
			}

			force = inputForce;
			break;

		case FORCE_GRAVITY:
			gravityForce = new ForceGravity();
			if ( gravityForce && gravityForce->Init(GetGameState()) ) {

				// Initialize it here
				// gravityForce->SetSomething(...)
			
			} else {
				fprintf(stderr, "ForceFactory: Failed to create new Input Force\n");
				if (gravityForce) {
						free(gravityForce);
						gravityForce = NULL;
				}	
			}

			force = gravityForce;
			break;
		default:
			fprintf(stderr, "ForceFactory: Unknown ID passed: %i\n", type);
			force = NULL;
	}
	
	return force;
}

/*void ForceFactory::DeleteForce(Force* obj) {
	obj->Delete();
	delete obj;
}*/

int ForceFactory::Init(GameState* _game_state) {
	SetGameState(_game_state);
	return 0;
}

void ForceFactory::Shutdown() {
}

ForceFactory::ForceFactory() {}
ForceFactory::~ForceFactory() {} 

//----------------------------
// force.h
//----------------------------

/* A force vector
 * all time increments are 1/60th of a second
 */

#ifndef FORCE_H
#define FORCE_H

#include <vector>
using namespace std;

class Force;
class GameState;

typedef vector<Force*> ForceList;

#include "globals.h"
#include "gameBase.h"
#include "vector2D.h"
#include "object.h"

enum ForceType {
	FORCE_GRAVITY,
	FORCE_INPUT,
	FORCE_SIMPLE_CIRCLE,
	FORCE_FRICTION
};

class Force : public GameBase {
	protected:
		ForceType type;
				
	public:
		bool Init(GameState* _game_state);
		void Shutdown();
		
		//! Compute the vector of the force that this Force creates
		virtual Vector2D GetForce(Object* obj) = 0;
		
		inline ForceType GetType() {return type;};
		// inline void SetType(ForceType t) {type = t;};

		Force();
		virtual ~Force();
};


#endif // FORCE_H

//----------------------------
// force.cpp
//----------------------------

#include "force.h"

bool Force::Init(GameState* _game_state) {
	return (game_state = _game_state) != NULL;
}

void Force::Shutdown() {
}

Force::Force() {}
Force::~Force() {}

//----------------------------
// basename.h
//----------------------------

#ifndef BASENAME_H
#define BASENAME_H

//! Return the basename of a pathname
char* basename (const char* name);

#endif // BASENAME_H

//----------------------------
// basename.cpp
//----------------------------

/* Return the basename of a pathname.
   This file is in the public domain. 
	 
	 Taken from: http://www.opensource.apple.com/darwinsource/projects/other/gcc_os-1809/libiberty/basename.c
	 */
/*

@deftypefn Supplemental char* basename (const char *@var{name})

Returns a pointer to the last component of pathname @var{name}.
Behavior is undefined if the pathname ends in a directory separator.

@end deftypefn

*/

#include <ctype.h>

#ifndef DIR_SEPARATOR
#define DIR_SEPARATOR '/'
#endif

#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \
  defined (__OS2__)
#define HAVE_DOS_BASED_FILE_SYSTEM
#ifndef DIR_SEPARATOR_2 
#define DIR_SEPARATOR_2 '\\'
#endif
#endif

/* Define IS_DIR_SEPARATOR.  */
#ifndef DIR_SEPARATOR_2
# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)
#else /* DIR_SEPARATOR_2 */
# define IS_DIR_SEPARATOR(ch) \
	(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))
#endif /* DIR_SEPARATOR_2 */

char* basename (const char* name) {
  const char *base;

#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
  /* Skip over the disk name in MSDOS pathnames. */
  if (isalpha(name[0]) && name[1] == ':') 
    name += 2;
#endif

  for (base = name; *name; name++)
    {
      if (IS_DIR_SEPARATOR (*name))
	{
	  base = name + 1;
	}
    }
  return (char *) base;
}

